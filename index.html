<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Galaxy</title>
  <style>
    :root {
      color-scheme: dark;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, sans-serif;
      background: radial-gradient(ellipse at center, #080819 0%, #020208 100%);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      display: block;
      width: min(100vw, 100vh);
      height: min(100vw, 100vh);
      max-width: 100%;
      max-height: 100%;
      filter: drop-shadow(0 0 20px rgba(118, 147, 255, 0.25));
      cursor: grab;
      touch-action: none;
    }

    canvas:active {
      cursor: grabbing;
    }

  </style>
</head>
<body>
<canvas id="galaxy"></canvas>
<script>
  const canvas = document.getElementById('galaxy');
const ctx = canvas.getContext('2d');

const PARTICLE_COUNT = 4500;
const INNER_GAP = 0.18;
const SPARKLE_COUNT = 110;
const BASE_ZOOM = 1.45;
const MIN_ZOOM = 0.55;
const MAX_ZOOM = 2.6;
const BASE_OFFSET_Y_RATIO = 0.1;
const MAX_SPIN_VELOCITY = 0.042;
const SPIN_DECAY_PER_MS = 0.99955;
const SPIN_EJECTION_THRESHOLD = 0.0013;
const SPIN_EJECTION_GAIN = 0.0045;
const TWO_PI = Math.PI * 2;
const RELEASE_EJECTION_GAIN = 1.25;
const MAX_EJECTION_LEVEL = 3.2;
const EJECTION_DECAY_PER_MS = 0.0006;
const RADIAL_FORCE = 0.23;
const RADIAL_DRAG = 0.975;
const RADIAL_RETENTION = 0.64;
const RADIAL_SETTLE_THRESHOLD = 0.22;
const RADIAL_SETTLE_DAMP = 0.93;
const SPARKLE_BASE_DRIFT = 0.00008;
const SPARKLE_WIND_COUPLING = 0.35;
const CHAIN_COUNT = 1;
const CHAIN_LENGTH = 120;
const CHAIN_SPACING = 5;
const CHAIN_BASE_SPEED = 0.7;
const CHAIN_GRAVITY = 0.00016;
const CHAIN_SPAWN_CHANCE = 0.0065;
const CHAIN_BUFFER = 320;
const COLOR_SHIFT_RANGE_DEG = 360;
const COLOR_PITCH_RANGE = Math.PI * 1.75; // larger value = slower change
const INITIAL_PITCH = 0.58;
const particles = [];
const sparkles = [];
const chains = [];
let width = 0;
let height = 0;
let centerX = 0;
let centerY = 0;
let galaxyRadius = 0;
let baseDistance = 0;
let zoom = BASE_ZOOM;
let yaw = 0.38;
let pitch = INITIAL_PITCH;
let sparkleYaw = yaw;
let sparklePitch = pitch;
let cameraOffsetX = 0;
let cameraOffsetY = 0;
let baseCameraOffsetX = 0;
let baseCameraOffsetY = 0;
let spinVelocity = 0;
let sparkleSpinVelocity = SPARKLE_BASE_DRIFT;
let ejectionLevel = 0;
let lastFrameTime = performance.now();
let orbitDirection = 1;

const pointer = {
  dragging: false,
  lastX: 0,
  lastY: 0,
  lastTime: 0,
  yawVelocity: 0,
  pitchVelocity: 0,
  spinAccumulator: 0,
  affectsSparkles: false
};

const activeTouchPointers = new Map();
let pinchLastDistance = null;

function clamp(value, min, max) {
  return Math.min(max, Math.max(min, value));
}

function wrapAngle(angle) {
  if (!Number.isFinite(angle)) {
    return 0;
  }
  angle = ((angle + Math.PI) % TWO_PI + TWO_PI) % TWO_PI - Math.PI;
  return angle;
}

function limitCameraOffset() {
  if (!galaxyRadius) return;
  const limit = galaxyRadius * 0.95;
  cameraOffsetX = clamp(cameraOffsetX, -limit, limit);
  cameraOffsetY = clamp(cameraOffsetY, -limit, limit);
}

function lerp(a, b, t) {
  return a + (b - a) * t;
}

function storeTouchPointer(event) {
  if (event.pointerType !== 'touch') return;
  activeTouchPointers.set(event.pointerId, { x: event.clientX, y: event.clientY });
}

function removeTouchPointer(event) {
  if (event.pointerType !== 'touch') return;
  activeTouchPointers.delete(event.pointerId);
}

function computePinchSnapshot() {
  if (activeTouchPointers.size < 2) {
    return null;
  }
  const touches = Array.from(activeTouchPointers.values());
  const first = touches[0];
  const second = touches[1];
  const dx = second.x - first.x;
  const dy = second.y - first.y;
  const distance = Math.hypot(dx, dy);
  return {
    distance,
    centerX: (first.x + second.x) / 2,
    centerY: (first.y + second.y) / 2
  };
}

function isPointInsideGalaxy(clientX, clientY) {
  if (!canvas || !galaxyRadius) {
    return false;
  }
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  const x = (clientX - rect.left) * scaleX;
  const y = (clientY - rect.top) * scaleY;
  const focusX = centerX - cameraOffsetX * zoom;
  const focusY = centerY - cameraOffsetY * zoom;
  const dx = x - focusX;
  const dy = y - focusY;
  const threshold = galaxyRadius * zoom * 0.85;
  return dx * dx + dy * dy <= threshold * threshold;
}

function applyZoomFromClient(factor, clientX = centerX, clientY = centerY) {
  if (!Number.isFinite(factor) || factor === 0 || !Number.isFinite(clientX) || !Number.isFinite(clientY)) {
    return;
  }

  const prevZoom = zoom;
  const newZoom = clamp(prevZoom * factor, MIN_ZOOM, MAX_ZOOM);
  if (newZoom === prevZoom) {
    return;
  }

  const zoomingOut = newZoom < prevZoom;

  if (zoomingOut) {
    zoom = newZoom;
    if (prevZoom > 0) {
      const decay = Math.pow(newZoom / prevZoom, 0.65);
      cameraOffsetX = baseCameraOffsetX + (cameraOffsetX - baseCameraOffsetX) * decay;
      cameraOffsetY = baseCameraOffsetY + (cameraOffsetY - baseCameraOffsetY) * decay;
    }

    const pullStrength = clamp(1 - newZoom / BASE_ZOOM, 0, 1);
    const pull = 0.18 + pullStrength * 0.55;
    const damping = clamp(1 - pull, 0, 1);
    cameraOffsetX = baseCameraOffsetX + (cameraOffsetX - baseCameraOffsetX) * damping;
    cameraOffsetY = baseCameraOffsetY + (cameraOffsetY - baseCameraOffsetY) * damping;

    if (Math.abs(cameraOffsetX - baseCameraOffsetX) < 0.01) cameraOffsetX = baseCameraOffsetX;
    if (Math.abs(cameraOffsetY - baseCameraOffsetY) < 0.01) cameraOffsetY = baseCameraOffsetY;
  } else {
    const worldX = cameraOffsetX + (clientX - centerX) / prevZoom;
    const worldY = cameraOffsetY + (clientY - centerY) / prevZoom;

    zoom = newZoom;
    cameraOffsetX = worldX - (clientX - centerX) / zoom;
    cameraOffsetY = worldY - (clientY - centerY) / zoom;
  }

  if (Math.abs(zoom - BASE_ZOOM) < 0.01) {
    zoom = BASE_ZOOM;
    cameraOffsetX = baseCameraOffsetX;
    cameraOffsetY = baseCameraOffsetY;
  }

  limitCameraOffset();
}

function resize() {
  const previousRadius = galaxyRadius || 0;
  const previousBaseOffsetY = previousRadius ? previousRadius * BASE_OFFSET_Y_RATIO : 0;

  const dpr = window.devicePixelRatio || 1;
  canvas.width = Math.round(window.innerWidth * dpr);
  canvas.height = Math.round(window.innerHeight * dpr);
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  width = canvas.width / dpr;
  height = canvas.height / dpr;
  centerX = width / 2;
  centerY = height / 2;
  galaxyRadius = Math.min(width, height) * 0.5;
  baseDistance = Math.min(width, height) * 1.35;
  baseCameraOffsetX = 0;
  baseCameraOffsetY = galaxyRadius * BASE_OFFSET_Y_RATIO;

  if (previousRadius > 0) {
    const scale = galaxyRadius / previousRadius;
    cameraOffsetX = baseCameraOffsetX + (cameraOffsetX - baseCameraOffsetX) * scale;
    cameraOffsetY = baseCameraOffsetY + (cameraOffsetY - previousBaseOffsetY) * scale;
  } else {
    cameraOffsetX = baseCameraOffsetX;
    cameraOffsetY = baseCameraOffsetY;
  }

  limitCameraOffset();
  initSparkles();
  initChains();
  sparkleYaw = yaw;
  sparklePitch = pitch;
  sparkleSpinVelocity = SPARKLE_BASE_DRIFT;
}

function initParticles() {
  particles.length = 0;
  const armCount = 4;

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    const radiusNorm = INNER_GAP + Math.pow(Math.random(), 1.5) * (1 - INNER_GAP);
    const radialJitter = (Math.random() - 0.5) * 0.04;
    const orbitalSpeed = 0.00032 + Math.random() * 0.0011;
    const heightNorm = (Math.random() - 0.5) * 0.4;
    const verticalAmpNorm = 0.002 + Math.random() * 0.007;
    const arm = Math.floor(Math.random() * armCount);
    const armOffset = arm * (Math.PI * 2 / armCount);
    const angleJitter = (Math.random() - 0.5) * 0.32;
    const baseHue = 190 + Math.random() * 50;
    const lightness = 55 + Math.random() * 25;
    const alpha = 0.38 + Math.random() * 0.42;

    particles.push({
      radiusNorm,
      radialJitter,
      angle: Math.random() * Math.PI * 2,
      orbitalSpeed,
      heightNorm,
      verticalAmpNorm,
      armOffset,
      angleJitter,
      size: (0.6 + Math.random() * 1.4) * (0.55 + (1 - radiusNorm) * 0.9),
      glow: 0.16 + Math.random() * 0.45,
      noisePhase: Math.random() * Math.PI * 2,
      escapeWeight: 0.4 + Math.random() * 1.2,
      escapePhase: Math.random() * Math.PI * 2,
      escapeCurve: 0.6 + Math.random() * 0.8,
      radialOffset: 0,
      radialVelocity: 0,
      bandPosition: Math.random(),
      baseHue,
      lightness,
      alpha
    });
  }
}

function initSparkles() {
  sparkles.length = 0;
  if (!galaxyRadius) {
    return;
  }

  for (let i = 0; i < SPARKLE_COUNT; i++) {
    const radius = galaxyRadius * (0.7 + Math.random() * 1.9);
    sparkles.push({
      radius,
      height: (Math.random() - 0.5) * galaxyRadius * 0.18,
      angle: Math.random() * Math.PI * 2,
      speed: (Math.random() * 0.00035 + 0.00008) * (Math.random() < 0.5 ? -1 : 1),
      flickerPhase: Math.random() * Math.PI * 2,
      flickerSpeed: 0.001 + Math.random() * 0.0015,
      size: 0.6 + Math.random() * 2.2,
      bandPosition: Math.random(),
      baseHue: 185 + Math.random() * 70
    });
  }
}

function createChain() {
  const edge = Math.floor(Math.random() * 4);
  let x, y, vx, vy;
  switch (edge) {
    case 0:
      x = Math.random() * width;
      y = -CHAIN_BUFFER;
      vx = (Math.random() - 0.5) * 0.5;
      vy = Math.random() * 0.6 + 0.4;
      break;
    case 1:
      x = Math.random() * width;
      y = height + CHAIN_BUFFER;
      vx = (Math.random() - 0.5) * 0.5;
      vy = -(Math.random() * 0.6 + 0.4);
      break;
    case 2:
      x = -CHAIN_BUFFER;
      y = Math.random() * height;
      vx = Math.random() * 0.6 + 0.4;
      vy = (Math.random() - 0.5) * 0.5;
      break;
    default:
      x = width + CHAIN_BUFFER;
      y = Math.random() * height;
      vx = -(Math.random() * 0.6 + 0.4);
      vy = (Math.random() - 0.5) * 0.5;
      break;
  }
  const speed = CHAIN_BASE_SPEED * (0.6 + Math.random() * 0.6);
  const hue = 200 + Math.random() * 80;
  return { x, y, vx, vy, speed, hue, alpha: 0.25 + Math.random() * 0.25 };
}

function initChains() {
  chains.length = 0;
  for (let i = 0; i < CHAIN_COUNT; i++) {
    chains.push(createChain());
  }
}

function fillBackground() {
  const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(centerX, centerY));
  gradient.addColorStop(0, 'rgba(10, 10, 32, 0.85)');
  gradient.addColorStop(0.5, 'rgba(2, 2, 12, 0.9)');
  gradient.addColorStop(1, 'rgba(0, 0, 5, 1)');

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, height);
}

function drawDust(focusX, focusY) {
  ctx.save();
  ctx.globalAlpha = 0.26;
  ctx.globalCompositeOperation = 'lighter';

  const dustRadius = galaxyRadius * (1.5 + Math.pow(zoom, 0.3) * 0.4);
  const innerRadius = dustRadius * 0.18;
  const gradient = ctx.createRadialGradient(focusX, focusY, innerRadius, focusX, focusY, dustRadius);
  gradient.addColorStop(0, 'rgba(40, 70, 150, 0.45)');
  gradient.addColorStop(0.45, 'rgba(80, 110, 190, 0.24)');
  gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, width, height);
  ctx.restore();
}

function drawCore(focusX, focusY) {
  ctx.save();
  ctx.globalCompositeOperation = 'lighter';

  const coreRadius = galaxyRadius * (0.08 + Math.pow(zoom, 0.25) * 0.025);
  const coreGradient = ctx.createRadialGradient(focusX, focusY, 0, focusX, focusY, coreRadius);
  coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.7)');
  coreGradient.addColorStop(0.4, 'rgba(230, 200, 255, 0.35)');
  coreGradient.addColorStop(0.75, 'rgba(150, 150, 255, 0.12)');
  coreGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

  ctx.fillStyle = coreGradient;
  ctx.beginPath();
  ctx.arc(focusX, focusY, coreRadius, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}

function updateChains(delta, focusX, focusY) {
  if (chains.length < CHAIN_COUNT && Math.random() < CHAIN_SPAWN_CHANCE) {
    chains.push(createChain());
  }
  if (!chains.length) return;
  const dt = Math.max(0.5, delta / 16);
  for (let i = 0; i < chains.length; i++) {
    const chain = chains[i];
    const dx = focusX - chain.x;
    const dy = focusY - chain.y;
    const distance = Math.hypot(dx, dy) + 1;
    const grav = CHAIN_GRAVITY * dt;
    chain.vx += (dx / distance) * grav;
    chain.vy += (dy / distance) * grav;
    const mag = Math.hypot(chain.vx, chain.vy) || 1;
    chain.vx /= mag;
    chain.vy /= mag;
    const step = chain.speed * dt * 0.8 * (0.5 + zoom * 0.3);
    chain.x += chain.vx * step * 16;
    chain.y += chain.vy * step * 16;

    if (
      chain.x < -CHAIN_BUFFER ||
      chain.x > width + CHAIN_BUFFER ||
      chain.y < -CHAIN_BUFFER ||
      chain.y > height + CHAIN_BUFFER
    ) {
      chains.splice(i, 1);
      i--;
    }
  }
}

function drawChains(hueShift, pitchBlend, focusX, focusY) {
  if (!chains.length) return;
  ctx.save();
  ctx.globalCompositeOperation = 'screen';
  for (const chain of chains) {
    const baseHue = (chain.hue + hueShift * 0.4) % 360;
    const headBrightness = 90;
    const tailBrightness = 35;
    for (let s = 0; s < CHAIN_LENGTH; s++) {
      const fade = 1 - s / CHAIN_LENGTH;
      if (fade <= 0.01) break;
      const px = chain.x - chain.vx * CHAIN_SPACING * s;
      const py = chain.y - chain.vy * CHAIN_SPACING * s;
      ctx.globalAlpha = chain.alpha * fade * 0.8;
      const brightness = lerp(headBrightness, tailBrightness, s / CHAIN_LENGTH);
      const size = 1 + fade * 1.5;
      ctx.fillStyle = `hsla(${baseHue}, 80%, ${brightness}%, 1)`;
      ctx.beginPath();
      ctx.arc(px, py, size, 0, TWO_PI);
      ctx.fill();

      if (s === 0) {
        ctx.globalAlpha = chain.alpha * 0.8;
        ctx.fillStyle = `hsla(${baseHue}, 95%, 95%, 1)`;
        ctx.beginPath();
        ctx.arc(px, py, size * 1.4, 0, TWO_PI);
        ctx.fill();

        ctx.globalAlpha = chain.alpha * 0.45;
        ctx.beginPath();
        ctx.arc(px, py, size * 2.3, 0, TWO_PI);
        ctx.fill();
      }
    }
  }
  ctx.restore();
  ctx.globalAlpha = 1;
}


function renderParticles(time, focusX, focusY, delta) {
  const viewDistance = baseDistance;
  const cosYaw = Math.cos(yaw);
  const sinYaw = Math.sin(yaw);
  const cosPitch = Math.cos(pitch);
  const sinPitch = Math.sin(pitch);
  const items = [];
  const ejectDrive = Math.min(2.2, ejectionLevel);
  const ejectNormalized = Math.min(1, ejectionLevel);
  const dt = Math.max(0.1, delta / 16);
  const drag = Math.pow(RADIAL_DRAG, dt);
  const rotationSign = orbitDirection || 1;
  const pitchOffset = wrapAngle(pitch - INITIAL_PITCH);
  const colorBlend = clamp(Math.abs(pitchOffset) / COLOR_PITCH_RANGE, 0, 1);
  const hueShift = colorBlend * COLOR_SHIFT_RANGE_DEG;

  for (const particle of particles) {
    particle.angle += particle.orbitalSpeed * rotationSign;

    const radiusBase = (particle.radiusNorm + particle.radialJitter * (1 - particle.radiusNorm)) * galaxyRadius;
    const baseRadius = Math.max(galaxyRadius * INNER_GAP * 0.85, radiusBase);

    const ripple = 0.5 + 0.5 * Math.sin(time * 0.0024 + particle.escapePhase);
    const outwardForce = ejectDrive * particle.escapeWeight * ripple;
    const inwardForce = particle.radialOffset * (0.12 + particle.escapeCurve * 0.05);
    particle.radialVelocity += (outwardForce - inwardForce) * dt * RADIAL_FORCE;
    particle.radialVelocity *= drag;
    particle.radialOffset = Math.max(0, Math.min(3.4, particle.radialOffset + particle.radialVelocity * dt * RADIAL_RETENTION));

    if (ejectNormalized < RADIAL_SETTLE_THRESHOLD) {
      const settle = Math.pow(RADIAL_SETTLE_DAMP, dt);
      particle.radialVelocity *= settle;
      particle.radialOffset *= settle;
    }

    const radiusScale = 1 + particle.radialOffset * (0.45 + 0.12 * ripple);
    const tangentPush = rotationSign * particle.radialOffset * galaxyRadius * (0.32 + 0.1 * ripple);
    const escapeLift = particle.radialOffset * galaxyRadius * 0.12 * ripple;

    const radius = baseRadius * radiusScale;
    const spiralTwist = radius * 0.0065;
    const localAngle = particle.angle + particle.armOffset + particle.angleJitter + spiralTwist;

    const wobble = Math.sin(time * 0.0012 + particle.noisePhase + radius * 0.01) * particle.verticalAmpNorm * galaxyRadius;
    const cosAngle = Math.cos(localAngle);
    const sinAngle = Math.sin(localAngle);
    const px = cosAngle * radius - sinAngle * tangentPush;
    const pz = sinAngle * radius + cosAngle * tangentPush;
    const py = particle.heightNorm * galaxyRadius * 0.16 + wobble + escapeLift;

    let x = px * cosYaw - pz * sinYaw;
    let z = px * sinYaw + pz * cosYaw;

    const y = py * cosPitch - z * sinPitch;
    z = py * sinPitch + z * cosPitch + escapeLift * 0.35;

    const perspective = viewDistance / (viewDistance + z);
    if (perspective <= 0) {
      continue;
    }

    const screenX = x * perspective;
    const screenY = y * perspective;

    const hue = (particle.baseHue + hueShift) % 360;
    const color = `hsla(${hue}, 80%, ${particle.lightness}%, ${particle.alpha})`;

    items.push({
      depth: z,
      x: focusX + screenX * zoom,
      y: focusY + screenY * zoom,
      size: Math.max(0.12, particle.size * perspective * Math.pow(zoom, 0.16) * (1 + particle.radialOffset * 0.18)),
      glow: particle.glow * perspective * (0.8 / Math.pow(zoom, 0.08)) * (1 + particle.radialOffset * 0.22),
      color
    });
  }

  items.sort((a, b) => b.depth - a.depth);

  ctx.save();
  ctx.globalCompositeOperation = 'screen';

  for (const item of items) {
    ctx.globalAlpha = 1;
    ctx.fillStyle = item.color;
    ctx.beginPath();
    ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
    ctx.fill();

    ctx.globalAlpha = Math.min(0.4, item.glow * 0.35);
    ctx.fillStyle = 'rgba(170, 200, 255, 0.16)';
    ctx.beginPath();
    ctx.arc(item.x, item.y, item.size * 0.65, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
  ctx.globalAlpha = 1;
}

function renderSparkles(time, focusX, focusY) {
  if (!sparkles.length) {
    return;
  }

  const viewDistance = baseDistance * 1.1;
  const cosYaw = Math.cos(sparkleYaw);
  const sinYaw = Math.sin(sparkleYaw);
  const cosPitch = Math.cos(sparklePitch);
  const sinPitch = Math.sin(sparklePitch);
  const pitchOffset = wrapAngle(pitch - INITIAL_PITCH);
  const colorBlend = clamp(Math.abs(pitchOffset) / COLOR_PITCH_RANGE, 0, 1);
  const hueShift = colorBlend * COLOR_SHIFT_RANGE_DEG;

  ctx.save();
  ctx.globalCompositeOperation = 'screen';

  for (const sparkle of sparkles) {
    sparkle.angle += sparkle.speed;

    const px = Math.cos(sparkle.angle) * sparkle.radius;
    const pz = Math.sin(sparkle.angle) * sparkle.radius;
    const py = sparkle.height;

    let x = px * cosYaw - pz * sinYaw;
    let z = px * sinYaw + pz * cosYaw;

    const y = py * cosPitch - z * sinPitch;
    z = py * sinPitch + z * cosPitch + baseDistance * 0.25;

    const perspective = viewDistance / (viewDistance + z);
    if (perspective <= 0) {
      continue;
    }

    const screenX = x * perspective;
    const screenY = y * perspective;
    const flicker = Math.pow(Math.max(0, Math.sin(time * sparkle.flickerSpeed + sparkle.flickerPhase)), 1.6);
    const alpha = (0.12 + flicker * 0.55) * (1 + Math.min(1, ejectionLevel) * 0.4);
    const radius = sparkle.size * perspective * (0.5 + flicker * 0.9) * Math.pow(zoom, 0.08) * (1 + Math.min(1, ejectionLevel) * 0.25);
    const hue = (sparkle.baseHue + hueShift) % 360;

    ctx.globalAlpha = alpha;
    ctx.fillStyle = `hsla(${hue}, 90%, 78%, 1)`;
    ctx.beginPath();
    ctx.arc(focusX + screenX * zoom, focusY + screenY * zoom, radius, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
  ctx.globalAlpha = 1;
}

function animate() {
  const time = performance.now();
  let delta = time - lastFrameTime;
  if (!Number.isFinite(delta) || delta <= 0) {
    delta = 16;
  }
  delta = Math.min(60, delta);

  spinVelocity *= Math.pow(SPIN_DECAY_PER_MS, delta);
  if (pointer.dragging) {
    spinVelocity = 0;
  }
  sparkleSpinVelocity *= Math.pow(SPIN_DECAY_PER_MS, delta);
  if (pointer.dragging && pointer.affectsSparkles) {
    sparkleSpinVelocity = SPARKLE_BASE_DRIFT;
  }

  if (Math.abs(spinVelocity) < 0.00001) {
    spinVelocity = 0;
  } else {
    yaw = wrapAngle(yaw + spinVelocity * delta);
  }
  orbitDirection = orbitDirection || 1;
  if (!pointer.affectsSparkles || !pointer.dragging) {
    const targetSpin = (spinVelocity !== 0 ? Math.sign(spinVelocity) : Math.sign(sparkleSpinVelocity || 1)) *
      (SPARKLE_BASE_DRIFT + Math.min(0.0004, Math.abs(spinVelocity) * SPARKLE_WIND_COUPLING));
    sparkleSpinVelocity += (targetSpin - sparkleSpinVelocity) * 0.05;
  }
  if (Math.abs(sparkleSpinVelocity) < 0.00001) {
    sparkleSpinVelocity = Math.sign(sparkleSpinVelocity || 1) * SPARKLE_BASE_DRIFT;
  }
  sparkleYaw = wrapAngle(sparkleYaw + sparkleSpinVelocity * delta);

  const spinAbs = Math.abs(spinVelocity);
  if (spinAbs > SPIN_EJECTION_THRESHOLD) {
    const normalized = Math.min(1, (spinAbs - SPIN_EJECTION_THRESHOLD) / (MAX_SPIN_VELOCITY - SPIN_EJECTION_THRESHOLD));
    ejectionLevel = Math.min(MAX_EJECTION_LEVEL, ejectionLevel + normalized * delta * SPIN_EJECTION_GAIN);
  }

  ejectionLevel = Math.max(0, ejectionLevel - delta * EJECTION_DECAY_PER_MS);

  const focusX = centerX - cameraOffsetX * zoom;
  const focusY = centerY - cameraOffsetY * zoom;
  const pitchOffset = wrapAngle(pitch - INITIAL_PITCH);
  const colorBlend = clamp(Math.abs(pitchOffset) / COLOR_PITCH_RANGE, 0, 1);
  const hueShift = colorBlend * COLOR_SHIFT_RANGE_DEG;

  fillBackground();
  drawDust(focusX, focusY);
  drawCore(focusX, focusY);
  updateChains(delta, focusX, focusY);
  drawChains(hueShift, colorBlend, focusX, focusY);
  renderParticles(time, focusX, focusY, delta);
  renderSparkles(time, focusX, focusY);

  lastFrameTime = time;
  requestAnimationFrame(animate);
}

function setupInteractions() {
  canvas.addEventListener('pointerdown', (event) => {
    storeTouchPointer(event);

    if (event.pointerType === 'touch' && activeTouchPointers.size > 1) {
      pointer.dragging = false;
      pointer.yawVelocity = 0;
      pointer.pitchVelocity = 0;
      pointer.spinAccumulator = 0;
      spinVelocity = 0;
      pointer.affectsSparkles = false;
      const pinch = computePinchSnapshot();
      pinchLastDistance = pinch ? pinch.distance : null;
    } else {
      pointer.dragging = true;
      pointer.lastX = event.clientX;
      pointer.lastY = event.clientY;
      pointer.lastTime = performance.now();
      pointer.yawVelocity = 0;
      pointer.pitchVelocity = 0;
      pointer.spinAccumulator = 0;
      spinVelocity = 0;
      pinchLastDistance = null;
      pointer.affectsSparkles = !isPointInsideGalaxy(event.clientX, event.clientY);
      if (pointer.affectsSparkles) {
        sparkleSpinVelocity = 0;
      }
    }

    if (canvas.setPointerCapture) {
      canvas.setPointerCapture(event.pointerId);
    }
  });

  canvas.addEventListener('pointermove', (event) => {
    if (event.pointerType === 'touch') {
      storeTouchPointer(event);
      const pinch = computePinchSnapshot();
      if (pinch) {
        if (pinchLastDistance && pinchLastDistance > 0) {
          const factor = clamp(pinch.distance / pinchLastDistance, 0.7, 1.3);
          applyZoomFromClient(factor, pinch.centerX, pinch.centerY);
        }
        pinchLastDistance = pinch.distance;
        pointer.dragging = false;
        pointer.yawVelocity = 0;
        pointer.pitchVelocity = 0;
        pointer.spinAccumulator = 0;
        spinVelocity = 0;
        pointer.affectsSparkles = false;
        return;
      }
      pinchLastDistance = null;
      if (!pointer.dragging) {
        pointer.dragging = true;
        pointer.lastX = event.clientX;
        pointer.lastY = event.clientY;
        pointer.lastTime = performance.now();
        pointer.yawVelocity = 0;
        pointer.pitchVelocity = 0;
        pointer.spinAccumulator = 0;
        spinVelocity = 0;
        pointer.affectsSparkles = !isPointInsideGalaxy(event.clientX, event.clientY);
        if (pointer.affectsSparkles) {
          sparkleSpinVelocity = 0;
        }
      }
    }

    if (!pointer.dragging) return;

    const dx = event.clientX - pointer.lastX;
    const dy = event.clientY - pointer.lastY;
    const now = performance.now();
    let dt = now - pointer.lastTime;
    if (!Number.isFinite(dt) || dt <= 0) {
      dt = 16;
    }

    const yawDirection = Math.cos(pitch) >= 0 ? 1 : -1;
    const yawDelta = dx * 0.003 * yawDirection;
    const pitchDelta = dy * 0.003;
    const sparkleYawDirection = Math.cos(sparklePitch) >= 0 ? 1 : -1;
    const sparkleYawDelta = dx * 0.003 * sparkleYawDirection;

    yaw = wrapAngle(yaw + yawDelta);
    if (yawDelta !== 0) {
      orbitDirection = Math.sign(yawDelta);
    }
    pitch = wrapAngle(pitch + pitchDelta);
    if (pointer.affectsSparkles) {
      sparkleYaw = wrapAngle(sparkleYaw + sparkleYawDelta);
      sparklePitch = wrapAngle(sparklePitch + pitchDelta);
    }

    pointer.yawVelocity = clamp(yawDelta / dt, -MAX_SPIN_VELOCITY, MAX_SPIN_VELOCITY);
    pointer.pitchVelocity = pitchDelta / dt;
    pointer.spinAccumulator += dx * yawDirection;
    if (Math.abs(pointer.spinAccumulator) > 1.5) {
      const dragDir = Math.sign(pointer.spinAccumulator);
      if (dragDir !== 0) {
        orbitDirection = dragDir;
      }
    }

    pointer.lastX = event.clientX;
    pointer.lastY = event.clientY;
    pointer.lastTime = now;
  });

  const endDrag = (event) => {
    removeTouchPointer(event);

    const pinch = computePinchSnapshot();
    if (!pointer.dragging) {
      pointer.spinAccumulator = 0;
      pinchLastDistance = pinch ? pinch.distance : null;

      if (!pinch && activeTouchPointers.size === 1) {
        const remaining = activeTouchPointers.values().next().value;
        pointer.dragging = true;
        pointer.lastX = remaining.x;
        pointer.lastY = remaining.y;
        pointer.lastTime = performance.now();
        pointer.yawVelocity = 0;
        pointer.pitchVelocity = 0;
        pointer.spinAccumulator = 0;
        spinVelocity = 0;
        pointer.affectsSparkles = !isPointInsideGalaxy(remaining.x, remaining.y);
        if (pointer.affectsSparkles) {
          sparkleSpinVelocity = 0;
        }
      }

      if (event && canvas.releasePointerCapture) {
        try {
          canvas.releasePointerCapture(event.pointerId);
        } catch (_) {
          // ignore release errors when pointer already ended
        }
      }
      return;
    }

    const dragAffectedSparkles = pointer.affectsSparkles;
    pointer.dragging = false;
    pointer.affectsSparkles = false;
    spinVelocity = clamp(pointer.yawVelocity, -MAX_SPIN_VELOCITY, MAX_SPIN_VELOCITY);
    sparkleSpinVelocity = dragAffectedSparkles
      ? clamp(pointer.yawVelocity, -MAX_SPIN_VELOCITY, MAX_SPIN_VELOCITY)
      : sparkleSpinVelocity;
    const dragDir = Math.sign(pointer.spinAccumulator);
    if (dragDir !== 0) {
      orbitDirection = dragDir;
    } else if (spinVelocity !== 0) {
      orbitDirection = Math.sign(spinVelocity);
    }
    pointer.spinAccumulator = 0;
    const extraSpin = Math.max(0, Math.abs(spinVelocity) - SPIN_EJECTION_THRESHOLD);
    if (extraSpin > 0) {
      const normalized = clamp(extraSpin / (MAX_SPIN_VELOCITY - SPIN_EJECTION_THRESHOLD), 0, 1);
      ejectionLevel = Math.min(MAX_EJECTION_LEVEL, ejectionLevel + normalized * RELEASE_EJECTION_GAIN);
    }

    if (event && canvas.releasePointerCapture) {
      try {
        canvas.releasePointerCapture(event.pointerId);
      } catch (_) {
        // ignore release errors when pointer already ended
      }
    }

    if (activeTouchPointers.size === 1) {
      const remaining = activeTouchPointers.values().next().value;
      pointer.dragging = true;
      pointer.lastX = remaining.x;
      pointer.lastY = remaining.y;
      pointer.lastTime = performance.now();
      pointer.yawVelocity = 0;
      pointer.pitchVelocity = 0;
      pointer.spinAccumulator = 0;
      spinVelocity = 0;
      pointer.affectsSparkles = !isPointInsideGalaxy(remaining.x, remaining.y);
      if (pointer.affectsSparkles) {
        sparkleSpinVelocity = 0;
      }
    }
  };

  canvas.addEventListener('pointerup', endDrag);
  canvas.addEventListener('pointercancel', endDrag);
  canvas.addEventListener('pointerleave', endDrag);

  canvas.addEventListener('wheel', (event) => {
    event.preventDefault();
    const factor = Math.exp(-event.deltaY * 0.0015);
    applyZoomFromClient(factor, event.clientX, event.clientY);
  }, { passive: false });

  window.addEventListener('resize', resize);
  window.addEventListener('blur', () => {
    pointer.dragging = false;
    activeTouchPointers.clear();
    pinchLastDistance = null;
    pointer.spinAccumulator = 0;
    pointer.yawVelocity = 0;
    pointer.pitchVelocity = 0;
    spinVelocity = 0;
    sparkleSpinVelocity = 0;
    pointer.affectsSparkles = false;
  });
}

resize();
initParticles();
initSparkles();
initChains();
setupInteractions();
animate();
</script>
</body>
</html>
